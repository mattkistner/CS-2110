#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/shipwreckedStart.h"
#include "images/islandPlay.h"
#include "images/seaman.h"
#include "images/winScreen.h"
#include "images/loseScreen.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};
int sharkCollision(struct sprite i, struct shark s, struct shark s2);
int treasureCollision(struct sprite i, struct treasure t);
char *update;

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct sprite islander;
  islander.x = 0;
  islander.y = HEIGHT / 4;
  islander.height = SEAMAN_HEIGHT;
  islander.width = SEAMAN_WIDTH;

  struct shark shark1;
  shark1.x = 200;
  shark1.y = 84;
  shark1.height = 10;
  shark1.width = 10;

  struct shark shark2;
  shark2.x = 59;
  shark2.y = 110;
  shark2.height = 10;
  shark2.width = 10;

  struct treasure treasa;
  treasa.x = 200;
  treasa.y = 120;
  treasa.height = 10;
  treasa.width = 10;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        waitForVBlank();
        drawFullScreenImageDMA(shipwreckedStart);
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          state = PLAY;
          islander.x = 0;
          islander.y = HEIGHT / 4;
          islander.height = SEAMAN_HEIGHT;
          islander.width = SEAMAN_WIDTH;
        }

        // state = ?
        break;
      case PLAY:
        islander.prevX = islander.x;
        islander.prevY = islander.y;
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          islander.y--;
        } else if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          islander.y++;
        } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          islander.x++;
        } else if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          islander.x--;
        }
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
        }
        waitForVBlank();
        drawFullScreenImageDMA(islandPlay);
        drawImageDMA(HEIGHT / 4, 0, islander.width, islander.height, seaman);
        drawRectDMA(shark1.y, shark1.x, shark1.width, shark1.height, GRAY);
        drawRectDMA(shark2.y, shark2.x, shark2.width, shark2.height, GRAY);
        drawRectDMA(treasa.y, treasa.x, treasa.width, treasa.height, YELLOW);
        undrawImageDMA(HEIGHT / 4, 0, islander.width, islander.height, seaman);
        drawImageDMA(islander.y, islander.x, islander.width, islander.height, seaman);
        //update = "Hmm an island...";
        drawString(130, 15, update, BLACK);

        if (islander.x + islander.width == 56 || islander.x == 62 ||
          islander.y + islander.height == 107 || islander.y == 113) {
          update = "WATCH OUT!";
          drawString(130, 15, "WATCH OUT!", BLACK);
        } else if (islander.x + islander.width == 197 || islander.x == 203 ||
          islander.y + islander.height == 117 || islander.y == 123) {
          update = "GETTING CLOSE!";
          drawString(130, 15, "GETTING CLOSE!", BLACK);
        }

        if (sharkCollision(islander, shark1, shark2)) {
          state = LOSE;
        } else if (treasureCollision(islander, treasa)) {
          state = WIN;
        }
        // state = ?
        break;
      case WIN:
        waitForVBlank();
        drawFullScreenImageDMA(winScreen);
        if (KEY_DOWN(BUTTON_SELECT, currentButtons) || KEY_DOWN(BUTTON_START, currentButtons)) {
          state = START;
        }
        break;
      case LOSE:
        waitForVBlank();
        drawFullScreenImageDMA(loseScreen);
        if (KEY_DOWN(BUTTON_SELECT, currentButtons) || KEY_DOWN(BUTTON_START, currentButtons)) {
          state = START;
        }
        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}

int sharkCollision(struct sprite i, struct shark s, struct shark s2) {
    if (i.x < s.x + s.width && i.x + i.width > s.x && i.y < s.y + s.height &&
      i.y + i.height > s.y) {
      return 1;
    } else if (i.x < s2.x + s2.width && i.x + i.width > s2.x && i.y < s2.y + s2.height &&
        i.y + i.height > s2.y) {
      return 1;
    } else if (i.x + i.width > 240 || i.x < 0 || i.y + i.height > 160 || i.y < 0) {
      return 1;
    }
    return 0;
  }

  int treasureCollision(struct sprite i, struct treasure t) {
    if (i.x < t.x + t.width && i.x + i.width > t.x && i.y < t.y + t.height &&
      i.y + i.height > t.y) {
      return 1;
    }
    return 0;
  }
